/*! JSONPatcherProxy version: 0.1.0-0-3 */
var JSONPatcherProxy=function(e){var t={};function r(o){if(t[o])return t[o].exports;var n=t[o]={i:o,l:!1,exports:{}};return e[o].call(n.exports,n,n.exports,r),n.l=!0,n.exports}return r.m=e,r.c=t,r.d=function(e,t,o){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:o})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(r.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var n in e)r.d(o,n,function(t){return e[t]}.bind(null,n));return o},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=0)}([function(e,t,r){"use strict";r.r(t),r.d(t,"JSONPatcherProxy",(function(){return o}));
/*!
 * https://github.com/Palindrom/JSONPatcherProxy
 * (c) 2017 Starcounter
 * MIT license
 *
 * Vocabulary used in this file:
 *  * root - root object that is deeply observed by JSONPatcherProxy
 *  * tree - any subtree within the root or the root
 */
const o=function(){function e(e){return-1==e.indexOf("/")&&-1==e.indexOf("~")?e:e.replace(/~/g,"~0").replace(/\//g,"~1")}function t(e,t){const r=[];let o=e._parenthoodMap.get(t);for(;o&&o.key;)r.unshift(o.key),o=e._parenthoodMap.get(o.parent);if(r.length){return"/"+r.join("/")}return""}function r(e,t,r){return r?function(e,t){void 0===e&&(e=null);void 0===t&&(t=null);return e!==t}(e,t):function(e,t){return e!==t}(e,t)}function o(e,t){this._isProxifyingTreeNow=!1,this._isObserving=!1,this._treeMetadataMap=new WeakMap,this._parenthoodMap=new WeakMap,"boolean"!=typeof t&&(t=!0),this._showDetachedWarning=t,this._originalRoot=e,this._cachedProxy=null,this._isRecording=!1,this._userCallback,this._defaultCallback,this._patches}return o.deepClone=function(e){switch(typeof e){case"object":return JSON.parse(JSON.stringify(e));case"undefined":return null;default:return e}},o.escapePathComponent=e,o.prototype._generateProxyAtKey=function(o,n,a){if(!n)return n;const i={set:(...o)=>function o(n,a,i,s){const c=t(n,a)+"/"+e(i),l=n._treeMetadataMap.get(s);n._treeMetadataMap.has(s)&&n._parenthoodMap.set(l.originalObject,{parent:a,key:i}),l&&!n._isProxifyingTreeNow&&(l.inherited=!0);let p=!1;const h=Array.isArray(a),u=h&&!Number.isInteger(+i.toString());s&&"object"==typeof s&&!n._treeMetadataMap.has(s)&&(u?(console.warn(`JSONPatcherProxy noticed a non-integer property ('${i}') was set for an array. This interception will not emit a patch. The value is an object, but it was not proxified, because it would not be addressable in JSON-Pointer`),p=!0):(n._parenthoodMap.set(s,{parent:a,key:i}),s=n._proxifyTreeRecursively(a,s,i)));const d=a[i],f=a.hasOwnProperty(i);if(h&&!u){const e=parseInt(i,10);e>a.length&&o(n,a,e-1+"",void 0)}const y=Reflect.set(a,i,s),_={op:"remove",path:c};if(void 0===s){if(!h&&!f)return y;{if(f&&!r(d,s,h))return y;h&&(_.value=null,_.op=f?"replace":"add");const e=n._treeMetadataMap.get(d);e&&(n._parenthoodMap.delete(d),n._disableTrapsForTreeMetadata(e),n._treeMetadataMap.delete(e))}}else{if(u)return"length"==i||p||console.warn(`JSONPatcherProxy noticed a non-integer property ('${i}') was set for an array. This interception will not emit a patch`),y;if(_.op="add",f&&(void 0!==d||h)){if(!r(d,s,h))return y;_.op="replace"}_.value=s}return n._defaultCallback(_),y}(this,...o),deleteProperty:(...r)=>function(r,o,n){const a=o[n],i=Reflect.deleteProperty(o,n);if(void 0!==a){const i=t(r,o)+"/"+e(n),s=r._treeMetadataMap.get(a);s&&(s.inherited?s.inherited=!1:(r._parenthoodMap.delete(s.originalObject),r._disableTrapsForTreeMetadata(s),r._treeMetadataMap.delete(a))),r._defaultCallback({op:"remove",path:i})}return i}(this,...r)},s=Proxy.revocable(n,i);return s.handler=i,s.originalObject=n,this._parenthoodMap.set(n,{parent:o,key:a}),this._treeMetadataMap.set(s.proxy,s),s.proxy},o.prototype._proxifyTreeRecursively=function(t,r,o){for(let t in r)r.hasOwnProperty(t)&&r[t]instanceof Object&&(r[t]=this._proxifyTreeRecursively(r,r[t],e(t)));return this._generateProxyAtKey(t,r,o)},o.prototype._proxifyRoot=function(e){this.pause(),this._isProxifyingTreeNow=!0;const t=this._proxifyTreeRecursively(void 0,e,"");return this._isProxifyingTreeNow=!1,this.resume(),t},o.prototype._disableTrapsForTreeMetadata=function(e){if(this._showDetachedWarning){const t="You're accessing an object that is detached from the observedObject tree, see https://github.com/Palindrom/JSONPatcherProxy#detached-objects";e.handler.set=(e,r,o)=>(console.warn(t),Reflect.set(e,r,o)),e.handler.set=(e,r,o)=>(console.warn(t),Reflect.set(e,r,o)),e.handler.deleteProperty=(e,t)=>Reflect.deleteProperty(e,t)}else delete e.handler.set,delete e.handler.get,delete e.handler.deleteProperty},o.prototype.observe=function(e,t){if(!e&&!t)throw new Error("You need to either record changes or pass a callback");return this._isRecording=e,this._userCallback=t,e&&(this._patches=[]),this._cachedProxy=this._proxifyRoot(this._originalRoot),this._cachedProxy},o.prototype.generate=function(){if(!this._isRecording)throw new Error("You should set record to true to get patches later");return this._patches.splice(0,this._patches.length)},o.prototype.revoke=function(){const e=t=>{for(let r in t)t.hasOwnProperty(r)&&t[r]instanceof Object&&e(t[r]);this._treeMetadataMap.has(t)&&this._treeMetadataMap.get(t).revoke()};e(this._cachedProxy)},o.prototype.disableTraps=function(){const e=t=>{for(let r in t)t.hasOwnProperty(r)&&t[r]instanceof Object&&e(t[r]);this._treeMetadataMap.has(t)&&this._disableTrapsForTreeMetadata(this._treeMetadataMap.get(t))};e(this._cachedProxy)},o.prototype.resume=function(){this._defaultCallback=e=>{this._isRecording&&this._patches.push(e),this._userCallback&&this._userCallback(e)},this._isObserving=!0},o.prototype.pause=function(){this._defaultCallback=()=>{},this._isObserving=!1},o}()}]).default;